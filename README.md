# 상세내용은 [Velog](https://velog.io/@blackb0x)에 정리하고 있습니다.

# 📝 Table of Contents

# 자료구조

- [배열(Array)](#배열)
- [큐(Queue)](#큐)
- [스택(Stack)](#스택)
- [연결리스트(LinkedList)](#연결리스트)
- [해시(Hash)](#해쉬)
- [트리(Tree)](#트리)
- [힙(Heap)](#힙)

# 알고리즘

- [알고리즘이란](#알고리즘이란)
- [시간복잡도](#시간복잡도)
- [삽입 정렬(Insertion Sort)](#삽입-정렬)
- [합병(머지,병합) 정렬(Merge Sort)](#합병-정렬)
- [버블(거품) 정렬(Bubble Sort)](#버블-정렬)
- [선택 정렬(Selection Sort)](#선택-정렬)
- [퀵 정렬(Quick Sort)](#퀵-정렬)
- [계수 정렬(Counting Sort)](#계수-정렬)
- [기수 정렬(Radix Sort)](#기수-정렬)
- [동적 프로그래밍(Dynamic programming)](#동적-프로그래밍)
- [탐욕(그리디) 알고리즘(greedy algorithm)](#탐욕-알고리즘)
- [최소 신장 트리(MST, minimum spanning tree)](#최소-신장-트리)
- [최단 경로 알고리즘](#최단-경로-알고리즘)
- [그래프 탐색](#그래프-탐색)
- [네트워크 플로우(network flow)](#네트워크-플로우)

# JS 100제

- [문제 1~50](https://www.notion.so/JS-100-1-0465a498481c471488646526a181087f)
- [문제 51~100](https://www.notion.so/JS-100-2-327372e894a843cf9c9430070c1ce5da)
- [정리](https://www.notion.so/a5a0fafe306e4cb78ec4476a272d156d?v=e116f6cdc6e34075bf8e4c0e56429a26)
- 출처 : [제주코딩베이스캠프](https://www.notion.so/JS-100-94d97d294dd14c9b911a02c840fa9f2d)

# 면접질문
- [자료1](https://realmojo.tistory.com/300)
- [자료2](https://blex.me/@yoyounn18/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%A7%81%EA%B5%B0-%EC%9B%B9%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C-%EB%8B%B5%EB%B3%80-%EB%8B%AC%EC%95%84%EB%B3%B4%EA%B8%B0)
- [자료3](https://blex.me/@baealex/%EC%B7%A8%EC%A4%80%EC%83%9D%EC%9D%B4-%EC%83%9D%EA%B0%81%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84)
- [자료4](https://m.blog.naver.com/z1004man/221878557383)
- [자료5](https://appear.github.io/2018/10/20/REACT/react-translate-01/)

---

## 배열

- 출처 : [Cookie님 Velog](https://velog.io/@ryu/JavaScript-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Array%EB%B0%B0%EC%97%B4)

### 백준
- [배열 문제](https://www.acmicpc.net/problem/tag/%EB%B0%B0%EC%97%B4)

[Top](#자료구조)

---

## 큐

- 출처 : [Cookie님 Velog](https://velog.io/@ryu/JavaScript-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Array%EB%B0%B0%EC%97%B4)

### 백준
- [큐 문제](https://www.acmicpc.net/problem/tag/%ED%81%90)
- [우선순위큐 문제](https://www.acmicpc.net/problem/tag/%EC%9A%B0%EC%84%A0%20%EC%88%9C%EC%9C%84%20%ED%81%90)

[Top](#자료구조)

---

## 스택

- 출처 : [Cookie님 Velog](https://velog.io/@ryu/JavaScript-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Array%EB%B0%B0%EC%97%B4)

### 백준
- [스택 문제](https://www.acmicpc.net/problem/tag/%EC%8A%A4%ED%83%9D)

[Top](#자료구조)

---

## 연결리스트

### 연결리스트
- 출처 : [소년코딩님 사이트](https://boycoding.tistory.com/33?category=916500)

### 이중 연결리스트
- 출처 : [소년코딩님 사이트](https://boycoding.tistory.com/34?category=916500)

### 백준
- [링크드리스트 문제](https://www.acmicpc.net/problem/tag/%EB%A7%81%ED%81%AC%EB%93%9C%20%EB%A6%AC%EC%8A%A4%ED%8A%B8)

[Top](#자료구조)

---

## 해시

- 출처 : [Evan Moon님 사이트](https://evan-moon.github.io/2019/06/25/hashtable-with-js/)

### 백준
- [해싱 문제](https://www.acmicpc.net/problem/tag/%ED%95%B4%EC%8B%B1)

[Top](#자료구조)

---

## 트리

- 출처 : [760kry님 Velog](https://velog.io/@760kry/data-structure-Tree-BinarySearchTree-javascript-%EA%B5%AC%ED%98%84-9fk5jh3tgz)

### 백준
- [트리 문제](https://www.acmicpc.net/problem/tag/%ED%8A%B8%EB%A6%AC)

[Top](#자료구조)

---

## 힙

- 출처 : [1ilsang님 사이트](https://1ilsang.dev/2020-04-02/js/heap)

### 백준
- [힙 문제](https://www.acmicpc.net/problem/tag/%ED%9E%99)

[Top](#자료구조)

---

## 알고리즘이란

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/57e22a778d6bcf0015231c8b)
  <br>[Top](#알고리즘)

---

## 시간복잡도

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/57ea2987fdea850015313534)<br>
  [Top](#알고리즘)

---

## 삽입 정렬

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/57e39fca76a7850015e6944a)
- 성능 : O(n^2)
- i : 뽑을 숫자의 위치를 선택할 변수
- temp : 뽑은 숫자 값을 저장할 변수
- j : 뽑은 숫자를 알맞은 위치에 넣을 때 사용할 변수

```javascript
var insertionSort = function (array) {
  var i = 1,
    j,
    temp;
  for (i; i < array.length; i++) {
    temp = array[i]; // 새로운 숫자를 선택함
    for (j = i - 1; j >= 0 && temp < array[j]; j--) {
      // 선택한 숫자를 이미 정렬된 숫자들과 비교하며 넣을 위치를 찾는 과정, 선택한 숫자가 정렬된 숫자보다 작으면
      array[j + 1] = array[j]; // 한 칸씩 뒤로 밀어낸다
    }
    array[j + 1] = temp; // 마지막 빈 칸에 선택한 숫자를 넣어준다.
  }
  return array;
};
insertionSort([5, 6, 1, 2, 4, 3]); // [1, 2, 3, 4, 5, 6]
```

[Top](#알고리즘)

---

## 합병 정렬

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/57ee1fc107c0b40015045cb4)
- 성능 : O(NlogN)
- mergeSort : 재귀를 하는 부분
- merge : 두 수끼리 비교하는 부분

```javascript
var mergeSort = function (array) {
  if (array.length < 2) return array; // 원소가 하나일 때는 그대로 내보냅니다.
  var pivot = Math.floor(array.length / 2); // 대략 반으로 쪼개는 코드
  var left = array.slice(0, pivot); // 쪼갠 왼쪽
  var right = array.slice(pivot, array.length); // 쪼갠 오른쪽
  return merge(mergeSort(left), mergeSort(right)); // 재귀적으로 쪼개고 합칩니다.
};
function merge(left, right) {
  var result = [];
  while (left.length && right.length) {
    if (left[0] <= right[0]) {
      // 두 배열의 첫 원소를 비교하여
      result.push(left.shift()); // 더 작은 수를 결과에 넣어줍니다.
    } else {
      result.push(right.shift()); // 오른쪽도 마찬가지
    }
  }
  while (left.length) result.push(left.shift()); // 어느 한 배열이 더 많이 남았다면 나머지를 다 넣어줍니다.
  while (right.length) result.push(right.shift()); // 오른쪽도 마찬가지
  return result;
}

mergeSort([5, 2, 4, 7, 6, 1, 3, 8]); // [1, 2, 3, 4, 5, 6, 7, 8]
```

[Top](#알고리즘)

---

## 버블 정렬

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/57f67519799d150015511c38)
- 성능 : O(n^2)

```javascript
var bubbleSort = function (array) {
  var length = array.length;
  var i, j, temp;
  for (i = 0; i < length - 1; i++) {
    // 순차적으로 비교하기 위한 반복문
    for (j = 0; j < length - 1 - i; j++) {
      // 끝까지 돌았을 때 다시 처음부터 비교하기 위한 반복문
      if (array[j] > array[j + 1]) {
        // 두 수를 비교하여 앞 수가 뒷 수보다 크면
        temp = array[j]; // 두 수를 서로 바꿔준다
        array[j] = array[j + 1];
        array[j + 1] = temp;
      }
    }
  }
  return array;
};

bubbleSort([5, 1, 7, 4, 6, 3, 2, 8]);
```

[Top](#알고리즘)

---

## 선택 정렬

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/57f728c85141fc5fe4f4ca89)
- 성능 : O(n^2)

```javascript
var selectionSort = function (array) {
  var length = array.length;
  var minIndex, temp, i, j;
  for (i = 0; i < length - 1; i++) {
    // 처음부터 훑으면서
    minIndex = i;
    for (j = i + 1; j < length; j++) {
      // 최솟값의 위치를 찾는다.
      if (array[j] < array[minIndex]) {
        minIndex = j;
      }
    }
    temp = array[minIndex]; // 최솟값을 저장하고
    array[minIndex] = array[i];
    array[i] = temp; // 최솟값을 제일 앞으로 보낸다.
  }
  return array;
};

selectionSort([5, 1, 4, 7, 2, 6, 8, 3]); // [1,2,3,4,5,6,7,8]
```

[Top](#알고리즘)

---

## 퀵 정렬

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/57f72d415141fc5fe4f4ca8b)
- 성능 : O(NlogN)
- 정렬하는 부분
- 재귀하는 부분

```javascript
var partition = function (array, left, right, pivotIndex) {
  // 정렬하는 부분
  var temp;
  var pivot = array[pivotIndex];
  while (left <= right) {
    // 왼쪽, 오른쪽 수를 규칙과 비교해 다음 수로 넘어갑니다.
    while (array[left] < pivot) left++;
    while (array[right] > pivot) right--;
    if (left <= right) {
      // 왼쪽이 기준보다 크고, 오른쪽이 기준보다 작으면
      temp = array[left];
      array[left] = array[right];
      array[right] = temp; // 서로 바꿔줍니다.
      left++;
      right--;
    }
  }
  temp = array[left];
  array[left] = array[pivotIndex];
  array[pivotIndex] = temp; // 마지막으로 기준과 만난 수를 바꿔줍니다. 기준의 위치는 이제 i입니다.
  return left;
};

var quickSort = function (array, left, right) {
  // 재귀하는 부분
  if (!left) left = 0;
  if (!right) right = array.length - 1;
  var pivotIndex = right; // 배열 가장 오른쪽의 수를 기준으로 뽑습니다.
  pivotIndex = partition(array, left, right - 1, pivotIndex); // right - 1을 하는 이유는 기준(현재 right)을 제외하고 정렬하기 위함입니다.
  if (left < pivotIndex - 1) quickSort(array, left, pivotIndex - 1); // 기준 왼쪽 부분 재귀
  if (pivotIndex + 1 < right) quickSort(array, pivotIndex + 1, right); // 기준 오른쪽 부분 재귀
  return array;
};

quickSort([4, 1, 7, 6, 3, 8, 2, 5]); // [1,2,3,4,5,6,7,8]
```

[Top](#알고리즘)

---

## 계수 정렬

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/58006da88475ed00152d6c4b)
- 성능 : O(n + k)
- array
- [개수를 저장할 공간]
- [결과]

```javascript
var countingSort = function (array, k) {
  var count = [],
    result = [];
  for (var i = 0; i <= k; i++) {
    // 모든 숫자의 개수를 일단 0으로 초기화합니다.
    count[i] = 0;
  }
  console.log(count, result, array.length);
  for (var j = 0; j < array.length; j++) {
    // 숫자의 개수를 세어 저장합니다.
    count[array[j]] += 1;
  }
  console.log(count, result, k);
  for (i = 0; i < k; i++) {
    // 누적합을 구합니다.
    count[i + 1] += count[i];
  }
  console.log(count, result);
  for (j = 0; j < array.length; j++) {
    // 누적합이 가리키는 인덱스를 바탕으로 결과에 숫자를  집어넣습니다.
    console.log(array[j], count[array[j]] - 1);
    result[count[array[j]] - 1] = array[j];
    count[array[j]] -= 1;
  }
  console.log(count, result);
  return result;
};

// 배열에 큰 수가 들어갈 수록 메모리를 많이 잡아먹기 때문에 좋지 않습니다.
countingSort([3, 4, 0, 1, 2, 4, 2, 4], 4); // [0,1,2,2,3,4,4,4]
```

[Top](#알고리즘)

---

## 기수 정렬

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/58007c338475ed00152d6c4c)
- O(dn)

```javascript
var counter = [[]];
var radixLSD = function (array, d) {
  var mod = 10;
  for (var i = 0; i < d; i++, mod *= 10) {
    // mod는 현재 정렬 중인 자리수를 나타내는 것으로 10부터 해서 100, 1000, ...으로 커집니다.
    for (var j = 0; j < array.length; j++) {
      var bucket = parseInt(array[j] % mod); // 같은 그룹으로 묶일 나머지를 나타내는 부분입니다.
      if (counter[bucket] == null) {
        counter[bucket] = [];
      }
      counter[bucket].push(array[j]); // 나머지 별로 묶어줍니다.
      console.log("bucket", bucket, counter[bucket]);
    }
    console.log(counter.slice(0));
    var pos = 0;
    for (var j = 0; j < counter.length; j++) {
      // counter에 저장한 묶음들(나머지 순서로 정렬됨)을 실제 배열에 반영해줍니다.
      var value = null;
      if (counter[j] != null) {
        while ((value = counter[j].shift()) != null) {
          array[pos++] = value;
        }
      }
    }
    console.log(array);
  }
  return array;
};
radixLSD([125, 383, 274, 96, 0, 9, 81, 72], 3); // [0,9,72,81,96,125,274,383]
```

[Top](#알고리즘)

---

## 동적 프로그래밍

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/584b979a580277001862f182)

- 막대기 자르기

```javascript
var p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30];
function cutRod(p, n) {
  var r = [0];
  for (var j = 1; j <= n; j++) {
    q = -1;
    for (var i = 1; i <= j; i++) {
      q = Math.max(q, p[i] + r[j - i]);
    }
    r[j] = q;
  }
  return r[n];
}
cutRod(p, 2); // 5
cutRod(p, 3); // 8
cutRod(p, 4); // 10
cutRod(p, 7); // 18
```

- 최장 공통 부분 수열 문제

```javascript
function LCS(x, y) {
  var i = x.length;
  var j = y.length;
  var result = [];
  for (var k = 0; k <= i; k++) {
    if (!result[k]) {
      result[k] = []; // 이전 계산 값 저장 공간
    }
  }
  for (k = 0; k <= i; k++) {
    for (var l = 0; l <= j; l++) {
      console.log(k, l);
      if (k === 0 || l === 0) {
        // 베이스 값 설정
        result[k][l] = 0;
      } else if (x[k - 1] === y[l - 1]) {
        // 마지막 두 문자 비교, 같으면
        result[k][l] = result[k - 1][l - 1] + 1;
      } else {
        // 마지막 두 문자가 다르면
        result[k][l] = Math.max(result[k - 1][l], result[k][l - 1]);
      }
    }
  }
  return result[i][j];
}
LCS("ABCBDAB", "BDCABA"); // 4
```

- 0/1 배낭 문제

```javascript
var item = [
  [1, 60, 10],
  [2, 100, 20],
  [3, 120, 30],
];
function zeroOneKnapsack(item, cap) {
  var m = [];
  for (var i = 0; i <= item.length; i++) {
    m[i] = [];
  }
  for (i = 0; i < item.length + 1; i++) {
    for (var j = 0; j <= cap; j++) {
      if (i === 0 || j === 0) {
        // 물건이나 무게가 없음
        m[i][j] = 0;
      } else if (item[i - 1][2] > j) {
        // 물건의 무게가 j보다 크면
        m[i][j] = m[i - 1][j];
      } else {
        m[i][j] = Math.max(
          m[i - 1][j],
          m[i - 1][j - item[i - 1][2]] + item[i - 1][1]
        );
      }
    }
  }
  return m[item.length][cap];
}
zeroOneKnapsack(item, 50); // 220
```

[Top](#알고리즘)

---

## 탐욕 알고리즘

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/584ba5c9580277001862f188)

- 활동 선택 문제

```javascript
var activity = [
  [1, 1, 3],
  [2, 2, 5],
  [3, 4, 7],
  [4, 1, 8],
  [5, 5, 9],
  [6, 8, 10],
  [7, 9, 11],
  [8, 11, 14],
  [9, 13, 16],
];
function activitySelection(act) {
  var result = [];
  var sorted = act.sort(function (prev, cur) {
    return prev[2] - cur[2]; // 끝나는 시간 순으로 정렬
  });
  var last = 0;
  sorted.forEach(function (item) {
    if (last < item[1]) {
      // 조건 만족 시 결과 집합에 추가
      last = item[2];
      result.push(item);
    }
  });
  return result.map(function (r) {
    return r[0]; // map을 한 이유는 그냥 몇 번째 행동이 선택되었는지 보여주기 위함.
  });
}
activitySelection(activity); // [1, 3, 6, 8]
```

- 분할 가능 배낭 문제

```javascript
var test = [
  [1, 60, 10],
  [2, 100, 20],
  [3, 120, 30],
];
function fractionalKnapsack(item, w) {
  var sorted = item.sort(function (prev, cur) {
    return cur[1] / cur[2] - prev[1] / prev[2]; // 무게 대비 가치 순으로 정렬
  });
  var limit = w;
  var result = 0;
  for (var i = 0; i < sorted.length; i++) {
    var cur = sorted[i];
    if (limit > 0) {
      if (limit >= cur[2]) {
        // 물건 무게가 제한 이하일 경우
        limit -= cur[2];
        result += cur[1];
      } else {
        // 물건 무게가 제한 초과일 경우
        result += (cur[1] / cur[2]) * limit; // 잘라서 넣음
        limit = 0;
      }
    } else {
      break;
    }
  }
  return result;
}
fractionalKnapsack(test, 50); // 240
```

[Top](#알고리즘)

---

## 최소 신장 트리

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/584bcd42580277001862f1a7)

- 프림 알고리즘

```javascript
Graph.prototype.mst = function () {
  var first = this.first;
  var inTreeCount = 0;
  while (first) {
    // 모든 inTree를 false로 초기화
    first.inTree = false;
    var arc = first.arc;
    while (arc) {
      arc.inTree = false;
      arc = arc.nextArc;
    }
    first = first.next;
  }
  this.first.inTree = true; // 첫 버텍스를 MST에 넣습니다.
  inTreeCount++;
  console.log("%s 버텍스가 추가되었습니다.", this.first.key);
  var temp = this.first;
  var current;
  var minArc; // 최소 아크를 저장
  var minTemp; // 최소 아크의 출발 버텍스를 저장
  while (inTreeCount != this.count) {
    // 모든 버텍스를 추가할 때까지
    while (temp) {
      current = temp;
      temp = temp.next;
      if (!current.inTree) continue;
      arc = current.arc;
      while (arc) {
        if (!arc.destination.inTree) {
          if (!minArc) minArc = arc;
          if (minArc.data > arc.data) {
            // 기존 최솟값보다 더 작은 값을 찾았을 때
            minArc = arc; // 최소 아크를 찾음
            minTemp = current; // 최소 아크의 출발 버텍스 저장
          }
        }
        arc = arc.nextArc;
      }
    }
    minArc.destination.inTree = true;
    minArc.inTree = true;
    inTreeCount++;
    console.log(
      "%s 버텍스에서 %s 버텍스로 향하는 가중치 %d의 아크가 추가되었습니다.",
      minTemp.key,
      minArc.destination.key,
      minArc.data
    );
    minArc = null;
    temp = this.first;
  }
};

var graph = new Graph();
graph.insertVertex("A");
graph.insertVertex("B");
graph.insertVertex("C");
graph.insertVertex("D");
graph.insertVertex("E");
graph.insertVertex("F");
insertTwoWayArc(graph, 6, "A", "B");
insertTwoWayArc(graph, 3, "A", "C");
insertTwoWayArc(graph, 2, "B", "C");
insertTwoWayArc(graph, 5, "B", "D");
insertTwoWayArc(graph, 3, "C", "D");
insertTwoWayArc(graph, 4, "C", "E");
insertTwoWayArc(graph, 2, "D", "E");
insertTwoWayArc(graph, 3, "D", "F");
insertTwoWayArc(graph, 5, "E", "F");
graph.mst();
// A 버텍스가 추가되었습니다.
// A 버텍스에서 C 버텍스로 향하는 가중치 3의 아크가 추가되었습니다.
// C 버텍스에서 B 버텍스로 향하는 가중치 2의 아크가 추가되었습니다.
// C 버텍스에서 D 버텍스로 향하는 가중치 3의 아크가 추가되었습니다.
// D 버텍스에서 E 버텍스로 향하는 가중치 2의 아크가 추가되었습니다.
// D 버텍스에서 F 버텍스로 향하는 가중치 3의 아크가 추가되었습니다.
```

[Top](#알고리즘)

---

## 최단 경로 알고리즘

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/584bd46f580277001862f1af)

- 다익스트라 알고리즘

```javascript
Graph.prototype.shortest = function (startKey) {
  var from = this.first;
  while (from) {
    if (from.key === startKey) {
      break;
    }
    from = from.next;
  }
  console.log("시작점은 %s입니다", from.key);
  var temp = this.first;
  var current;
  var arc;
  while (temp) {
    // 모든 버텍스 최단거리를 Infinity로 초기화
    temp.distance = Infinity;
    temp = temp.next;
  }
  temp = this.first;
  temp.distance = 0;
  while (temp) {
    // 반복문을 돌며 최단 거리를 찾음
    current = temp;
    temp = temp.next;
    arc = current.arc;
    while (arc) {
      if (arc.destination.distance > current.distance + arc.data) {
        arc.destination.distance = current.distance + arc.data;
      }
      arc = arc.nextArc;
    }
  }
  temp = this.first;
  while (temp) {
    console.log("%s까지의 최단 거리는 %d입니다", temp.key, temp.distance);
    temp = temp.next;
  }
};

var graph = new Graph();
graph.insertVertex("A");
graph.insertVertex("B");
graph.insertVertex("C");
graph.insertVertex("D");
graph.insertVertex("E");
graph.insertVertex("F");
insertTwoWayArc(graph, 6, "A", "B");
insertTwoWayArc(graph, 3, "A", "C");
insertTwoWayArc(graph, 2, "B", "C");
insertTwoWayArc(graph, 5, "B", "D");
insertTwoWayArc(graph, 3, "C", "D");
insertTwoWayArc(graph, 4, "C", "E");
insertTwoWayArc(graph, 2, "D", "E");
insertTwoWayArc(graph, 3, "D", "F");
insertTwoWayArc(graph, 5, "E", "F");
graph.shortest("A");
// A까지의 최단 거리는 0입니다.
// B까지의 최단 거리는 5입니다.
// C까지의 최단 거리는 3입니다.
// D까지의 최단 거리는 6입니다.
// E까지의 최단 거리는 7입니다.
// F까지의 최단 거리는 9입니다.
```

[Top](#알고리즘)

---

## 그래프 탐색

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/5870153c37e1c80018b64eb0)

- DFS

```javascript
Graph.prototype.dfs = function () {
  var stack = new Stack();
  var temp = this.first;
  while (temp) {
    temp.inTree = false;
    temp = temp.next;
  }
  temp = this.first;
  stack.push(temp); // 스택에 첫 버텍스를 넣음
  temp.inTree = true;
  while (stack.count) {
    // 탐색을 완료할 때까지
    temp = stack.pop(); // 넣었던 버텍스를 하나씩 꺼냄
    console.log(temp.key);
    temp.inTree = true;
    var arc = temp.arc;
    while (arc) {
      if (!arc.destination.inTree) {
        stack.push(arc.destination); // 꺼낸 것과 연결된 버텍스들을 스택에 넣음
        arc.destination.inTree = true;
      }
      arc = arc.nextArc;
    }
  }
};
graph.dfs(); // A, X, H, P, E, Y, M, J, G
```

- BFS

```javascript
Graph.prototype.bfs = function () {
  var queue = new Queue();
  var temp = this.first;
  while (temp) {
    temp.inTree = false;
    temp = temp.next;
  }
  temp = this.first;
  queue.enqueue(temp); // 첫 버텍스를 큐에 넣음
  temp.inTree = true;
  while (queue.count) {
    // 탐색을 완료할 때까지
    temp = queue.dequeue(); // 큐에서 하나씩 꺼냄
    console.log(temp.key);
    temp.inTree = true;
    var arc = temp.arc;
    while (arc) {
      if (!arc.destination.inTree) {
        queue.enqueue(arc.destination); // 꺼낸 것과 연결된 버텍스들을 큐에 넣음
        arc.destination.inTree = true;
      }
      arc = arc.nextArc;
    }
  }
};
graph.bfs(); // A, X, G, H, P, E, M, Y, J
```

[Top](#알고리즘)

---

## 네트워크 플로우

- 출처 : [Zero Cho님 사이트](https://www.zerocho.com/category/Algorithm/post/5893405b588acb00186d39e0)

```javascript
Graph.prototype.fordFulkerson = function(start, end) {
  function ReArc(data, dest) { // 잔여 아크 생성자 선언
    this.data = data || 0;
    this.destination = dest;
    this.reverse = null;
  }
  var vertex = this.first;
  while (vertex) { // 모든 아크에 잔여 아크를 추가하는 작업
    var arc = vertex.arc;
    while (arc) {
      var reArc = new ReArc(arc.capacity - arc.data, arc.destination);
      var reArc2 = new ReArc(arc.data, vertex);
      reArc.reverse = reArc2; // 두 잔여 아크는 서로 역방향의 관계
      reArc2.reverse = reArc;
      vertex.residual = vertex.residual || [];
      vertex.residual.push(reArc);
      arc.destination.residual = arc.destination.residual || [];
      arc.destination.residual.push(reArc2);
      arc = arc.nextArc;
    }
    vertex = vertex.next;
  }
  var self = this;

  function findArcInPath(path, reArc, start) { // 잔여 아크가 이미 지나온 경로 안에 있는지 찾는 함수
    for (var i = 0; i < path.length; i++) {
      if (path[i][0] === reArc || reArc.destination === path[i][2]) {
         return true;
      }
    }
    return false;
  }

  function findPath(from, to, path) { // 잔여 네트워크의 경로를 재귀적으로 찾는 함수
    if (from === to) return path;
    vertex = self.first;
    var reArcs;
    var arc;
    while (vertex) {
      if (vertex.key === from)
        reArcs = vertex.residual;
        arc = vertex.arc;
        break;
      }
      vertex = vertex.next;
    }
    for (var i = 0; i < reArcs.length; i++) { // 잔여 아크 전체를 탐색
      var residual = reArcs[i].data;
      if (residual > 0 && !findArcInPath(path, reArcs[i], vertex)) { // 잔여 아크 용량이 1 이상이고 지나온 패스에 없으면
         var pathCopy = path.slice();
         pathCopy.push([reArcs[i], arc, vertex]);
        var result = findPath(reArcs[i].destination.key, to, pathCopy); // 재귀적으로 다음 패스를 찾음
        if (result) return result;
      }
    }
    return null;
  }

  var path = findPath(start, end, []);
  while (path) { // 잔여 네트워크에 경로가 없을 때까지 반복적으로 찾고 증강
    var flow = Infinity;<
    for (var i = 0; i < path.length; i++) {
      if (path[i][0].data < flow) flow = path[i][0].data; // 추가할 수 있는 물의 양 찾기
    }
    for (var i = 0; i < path.length; i++) {
      path[i][0].data -= flow; // 잔여 아크에 흐름 뺌
      path[i][0].reverse.data += flow; // 잔여 역아크에 흐름 추가
      path[i][1].data += flow; // 아크에 흐름 추가
    }
    path = findPath(start, end, []);
  }
  var sum = 0;
  vertex = self.first;
  while (vertex) { // 마지막으로 시작점의 유량을 체크하면
    if (vertex.key === start) {
      arc = vertex.arc;
      while (arc) {
        sum += arc.data;
        arc = arc.nextArc;
      }
      break;
    }
    vertex = vertex.next;
  }
  return sum;
};

var graph = new Graph();
graph.insertVertex('s');
graph.insertVertex('w');
graph.insertVertex('y');
graph.insertVertex('x');
graph.insertVertex('z');
graph.insertVertex('t');
graph.insertArc(1, 's', 'w', 3);
graph.insertArc(2, 'w', 'x', 2);
graph.insertArc(2, 'x', 't', 3);
graph.insertArc(2, 's', 'y', 2);
graph.insertArc(1, 'y', 'w', 3);
graph.insertArc(1, 'x', 'y', 1);
graph.insertArc(2, 'y', 'z', 3);
graph.insertArc(1, 'z', 'x', 3);
graph.insertArc(1, 'z', 't', 2);
graph.fordFulkerson('s', 't'); // 4
```

[Top](#알고리즘)

---
